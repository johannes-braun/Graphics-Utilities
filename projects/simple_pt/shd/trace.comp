#include <ext/bvh.h>
#include <ext/random.h>
#include <ext/sampling.h>
#include <ext/bsdf.h>
#include <ext/line_space.h>

#define PI 3.1415926535
#define INV_PI 0.31830988618
#define TAU 6.282185317

layout(local_size_x = 8, local_size_y = 8) in;

layout(binding=0, std140) uniform Data
{
    mat4 camera_matrix;
    vec4 camera_position;

    layout(rgba32f) image2D img;
    uintptr_t bvh;
    uintptr_t vbo;
    uintptr_t ibo;
    uintptr_t grid_line_space;
    samplerCube cubemap;
    float seed;
    int frames;
};

struct vertex {
    vec3 position;
    uint meta;
    vec3 normal;
    uint meta1;
    vec2 uv;
    uintptr_t meta2;
};

struct triangle {
    uint a;
    uint b;
    uint c;
};

const float random_primes[6] = { 69019.f, 96013.f, 32159.f, 22783.f, 87011.f, 45263.f };
void init_random(ivec2 pixel, float seed)
{
    random_value(int(pixel.x * random_primes[0] + pixel.y * random_primes[1] + random_primes[2] * seed));
}

int _current_prime = 0;
float next_random()
{
    return random_value(_current_prime = (_current_prime + 1) % 6);
}

vec3 environment(samplerCube map, vec3 direction, float clamp_color, int mip)
{
    return clamp(pow(textureLod(map, direction, mip).rgb, vec3(1/2.8f)), 0, clamp_color);
}

struct light_path
{
    vec4 position;
    vec4 normal;
    vec4 color;
};

struct ls_result
{
    vec2 bary;
    int triangle;
    float distance;
};

ls_result resolve_line_space(vec3 orig, vec3 dir, uintptr_t gls, uintptr_t vers, uintptr_t indices, float maxdist)
{
    ls_result result;
    
    line hit_line = get_line_grid(grid_line_space, orig, dir, maxdist);
    triangle* tri = (((triangle*)indices) + hit_line.triangle);
    result.triangle = hit_line.triangle;

    if (result.triangle == -1)
        return result;

    vertex* vertices = (vertex*)vers;
    intersect_triangle_plane(orig, dir, vertices[tri->a].position.xyz, vertices[tri->b].position.xyz, vertices[tri->c].position.xyz, result.distance, result.bary);
    return result;
}

const int bounce_count = 6;
const int lpcount = 4;
light_path lighting[lpcount];

void main()
{
    const ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    const ivec2 imgsize = imageSize(img);
    const float count = imgsize.x * imgsize.y;
    const vec2 inv_size = 1.f / imgsize;

    if(any(greaterThanEqual(pixel, imgsize)))
        return;

    init_random(pixel, seed);
    vec2 random_sample = random_hammersley_2d(next_random() * count, 1 / count);
    vec2 uv = ((pixel + random_sample) * inv_size - 0.5f) * 2.f;
    vec3 direction = normalize((camera_matrix * vec4(uv, 0, 1)).xyz);
    vec3 origin = camera_position.xyz;

    ls_result ls_r = resolve_line_space(origin, direction, grid_line_space, vbo, ibo, 1.f / 0.f);

    vertex* vertices2 = (vertex*) vbo;
    triangle* tri = (((triangle*)ibo) + ls_r.triangle);

    vec2 lsbary = ls_r.bary;
    float lsdist = ls_r.distance;
    const vec3 lsnorm = vertices2[tri->b].normal.xyz * lsbary.x + vertices2[tri->c].position.xyz * lsbary.y + vertices2[tri->a].position.xyz * (1 - lsbary.x - lsbary.y);

    imageStore(img, pixel, ls_r.triangle == -1 ? vec4(0) : vec4(lsnorm, 1));
    return;
    
    bvh_state_set_mode(bvh_mode_nearest);
    bvh_result current_result = bvh_hit(origin.xyz, direction.xyz, bvh, ibo, vbo, 10000000000.f);

    const vec4 last_color = imageLoad(img, pixel);
    vec4 color = vec4(0);
    if(current_result.hits)
    {
        vec3 radiance = vec3(1);
        bool was_diffuse = false;
        for(int i=0; i<bounce_count; ++i)
        {
            if(current_result.hits)
            {
                vertex* vertices = (vertex*) vbo;
                triangle* triangles = ((triangle*) ibo) + current_result.near_triangle;
            
                #define barycentric_resolve(param, res) (\
                    vertices[triangles->b].param * res.near_barycentric.x + \
                    vertices[triangles->c].param * res.near_barycentric.y + \
                    vertices[triangles->a].param * (1-res.near_barycentric.x-res.near_barycentric.y)\
                )

                const vec3 position = barycentric_resolve(position, current_result);
                const vec3 normal = normalize(barycentric_resolve(normal, current_result));
                const vec2 uv = barycentric_resolve(uv, current_result);
                const uint meta = vertices[triangles->a].meta;
                const float ext = meta == 1 ? 1.f : 0.6f;
                const float rough = meta == 1 ? 0.f : 0.04f;

                random_sample = random_hammersley_2d(next_random() * count, 1/count);
                vec3 hemisphere = sample_cosine_hemisphere(random_sample);
                vec3 world_hemisphere = bsdf_local_to_world(hemisphere, normal);

                const vec3 lamp = vec3(0.11, 29, -30.0);
                const vec3 lamp_color = vec3(2900);
                const float lamp_radius = 0.0001f;
                
                const vec3 lamp_position = lamp + sample_uniform_sphere(random_sample) * lamp_radius;
                const vec3 to_lamp = normalize(lamp_position - position);

                vec3 lorig = lamp_position;
                vec3 ldir = (sample_uniform_sphere(random_sample) * 0.0001f + position) - lamp_position;
                vec3 lcol = lamp_color;
                float dist = 0;
                for(int p = 0; p < lpcount; ++p)
                {
                    ldir = normalize(ldir);
                    bvh_state_set_mode(bvh_mode_nearest);
                    bvh_result lamp_result = bvh_hit(lorig.xyz, ldir.xyz, 
                                bvh, ibo, vbo, 10000000000.f);

                    if(lamp_result.hits)
                    {
                        triangles = ((triangle*) ibo) + lamp_result.near_triangle;
                        lighting[p].position = vec4(barycentric_resolve(position, lamp_result), 1);

                        vec3 ld = lighting[p].position.xyz - lorig;
                        dist += length(ld);

                        lighting[p].normal = vec4(normalize(barycentric_resolve(normal, lamp_result)), 0);

                        const float rext = 1.4f;
                        const float rrough = 0.0f;

                        const vec3 facet_normal = bsdf_local_to_world(
                            ggx_importance_hemisphere(
                                ggx_importance_sample(random_sample, rrough)
                            ), lighting[p].normal.xyz
                        );

                        const vec3 lnorm = normalize(facet_normal.xyz);
                        lighting[p].color = 2*INV_PI * vec4(lcol, 1) / max(dist * dist, 1);

                        const bool internal = dot(lnorm, ldir) < 0;
                        const float eta = internal ? (1/1.5f) : 1.5f;
                        const float fresnel = bsdf_fresnel_coefficient(normalize(ldir), lnorm.xyz, 1.5f, rext);
                        const bool total = bsdf_is_total_reflection(eta, ldir, faceforward(lnorm, ldir, lnorm));
                        const float nrand = next_random();
                        
                        if(next_random() < fresnel)
                        {
                            ldir = reflect(ldir, faceforward(lnorm, ldir, lnorm));
                            lorig = lighting[p].position.xyz + 1e-3f * ldir;
                            lcol *= vec3(1,1, 1);
                        }
                        else if(vertices[triangles->a].meta == 1)
                        {
                            ldir = refract(ldir, faceforward(lnorm, ldir, lnorm), eta);
                            lorig = lighting[p].position.xyz + 1e-3f * ldir;
                            lcol *= vec3(1);
                        }
                        else{
                            vec3 hm = sample_cosine_hemisphere(random_sample);
                            vec3 whm = bsdf_local_to_world(hm, lnorm);
                            vec4 diffuse = vec4(1, 1, 1, 1);
                            ldir = normalize(whm);
                            lorig = lighting[p].position.xyz + 1e-4f * ldir;
                            lcol *= abs(dot(direction, normal)) * diffuse.rgb;
                        }
                    }
                }


                vec3 light_color = vec3(0);
                if(dot(normal, to_lamp) > 0.f)
                {
                    const float dist = distance(position, lamp);
                    bvh_state_set_mode(bvh_mode_any);
                    bvh_result shadow_result = bvh_hit(position.xyz + 1e-3f * to_lamp, to_lamp, bvh, ibo, vbo, dist);

                    if(!shadow_result.hits)
                    {
                        light_color = dot(normal, to_lamp) * lamp_color / (dist * dist);
                    }
                    for(int p = 0; p < lpcount; ++p)
                    {
                        if(lighting[p].normal.w == -1)
                            break;

                        const vec3 pos_difference = lighting[p].position.xyz - position.xyz;
                        const vec3 pos_difference_n = normalize(pos_difference);
                        light_color += lighting[p].color.rgb * vec3(
                            clamp(dot(pos_difference_n, normalize(normal.xyz)), 0.f, 4) *
                            clamp(dot(-pos_difference_n, normalize(lighting[p].normal.xyz)), 0.f, 4) *
                            clamp(1.f / max(dot(pos_difference, pos_difference), 0.1), 0, 4));
                    }
                }

                const vec3 facet_normal = bsdf_local_to_world(
                    ggx_importance_hemisphere(
                        ggx_importance_sample(random_sample, rough)
                    ), normal.xyz
                );
                const float fresnel = bsdf_fresnel_coefficient(direction, facet_normal.xyz, 1.5f, ext);
                
                const bool internal = dot(facet_normal, direction) < 0;
                const float eta = internal ? (1/1.5f) : 1.5f;
                const bool total = bsdf_is_total_reflection(eta, direction, faceforward(facet_normal, direction, facet_normal));

                if(next_random() < fresnel || total)
                {
                    direction = reflect(direction, faceforward(facet_normal, direction, facet_normal));
                    origin = position + 1e-4f * direction;
                    radiance *= vec3(1, 1, 1);
                }
                else
                {
                    if(meta == 0)
                    {
                        was_diffuse = true;
                        vec4 diffuse = vec4(1, 1, 1, 1);
                        direction = normalize(world_hemisphere);
                        color += vec4(light_color, 1) * INV_PI * vec4(radiance, 1) * diffuse;
                        origin = position + 1e-4f * direction;
                        radiance *= abs(dot(direction, normal)) * diffuse.rgb;
                    }
                    else
                    {
                        direction = refract(direction, faceforward(facet_normal, direction, facet_normal), eta);
                        origin = position + 1e-4f * direction;
                        radiance *= vec3(1);
                        i = max(1, i-1);
                    }
                }

                if(dot(radiance, radiance) < 0.01f)
                    break;

                bvh_state_set_mode(bvh_mode_nearest);
                current_result = bvh_hit(origin.xyz, direction.xyz, bvh, ibo, vbo, 10000000000.f);
            }
            else
            {
                color += vec4(radiance * environment(cubemap, direction, 1.1f, 3), 1);
                break;
            }
        }
    }
    else
        color = vec4(environment(cubemap, direction, 2.f, 0), 0);

    imageStore(img, pixel, mix(last_color, color, 1.f / frames));
}