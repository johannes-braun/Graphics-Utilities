#include "../ext/bvh.h"
#include "../ext/random.h"
#include "../ext/bsdf.h"

layout(local_size_x = 16, local_size_y = 16) in;

layout(rgba16f) uniform image2D target_image;
uniform samplerCube cubemap;
uniform float random_gen;
uniform vec3 camera_position;
uniform mat4 camera_matrix;

uniform uintptr_t meshes;
uniform int num_meshes = 0;

uniform ivec2 offset;
uniform int max_samples = 4;
uniform int sample_blend_offset = 0;

struct mesh
{
    intptr_t vertices;
    intptr_t elements;
    intptr_t bvh;
    intptr_t material;
    mat4 inv_model;
    mat4 model;
};

struct material
{
    vec3 glass_tint;
    float roughness_sqrt;
    vec3 reflection_tint;
    float glass;
    vec3 base_color;
    float ior;
    float extinction_coefficient;

    float _p[3];
};

struct vertex {
    vec4 position;
    vec4 uv;
    vec4 normal;
};

struct triangle {
    uint a;
    uint b;
    uint c;
};

vec3 cosine_hemisphere(vec2 uv)
{
	// (Uniformly) sample a point on the unit disk
    float r = sqrt(uv.x);
    float theta = 2 * 3.14152692 * uv.y;
    float x = r * cos(theta);
    float y = r * sin(theta);

    // Project point up to the unit sphere
    float z = sqrt(max(0.f, 1 - x * x - y * y));
    return vec3(x, y, z);
}

vec3 uniform_sphere(vec2 uv)
{
	float cosTheta = 2 * uv.x - 1;
	float phi = uv.y * 2.f * 3.14152692;
	float sinTheta = sqrt(max(0, 1 - cosTheta * cosTheta));
	return vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);
}

bool isTotalReflection(float ior_in, float ior_out, vec3 incoming, vec3 micro_normal)
{
	float c = abs(dot(incoming, micro_normal));
	return c * c < -(ior_out / ior_in) + 1;
}

void main()
{
    const float one_over_pi = 0.31830988618;

    ivec2 target_size = imageSize(target_image);
    float count = target_size.x * target_size.y;
    vec2 inv_target_size = 1.f / target_size;
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy)+offset;

    if(any(greaterThanEqual(pixel, target_size)))
        return;

    for(int s=0; s<max_samples; ++s)
    {
        vec4 last_color = imageLoad(target_image, pixel);
        float alpha = 1.f;
        vec3 color = vec3(0);

        float rand_val = random_value(int(pixel.x * 20323 + pixel.y * 43143 + 29012 * random_gen));
        vec2 random_sample = random_hammersley_2d(rand_val * count, 1/count);
        vec2 uv = (pixel + random_sample-0.5f) * inv_target_size - 0.5f;
        vec3 direction = vec3(camera_matrix * vec4(uv*2.f, 0, 1));
        vec3 origin = camera_position;

        vec3 rad = vec3(1);

        mesh* mesh_buffer = (mesh*)meshes;
        for(int i=0; i<9; ++i)
        {
            mesh* current_mesh = mesh_buffer + 0;
            bvh_state_set_mode(bvh_mode_nearest);
            bvh_result result;
            result.hits = false;
            float nearest = 1.f/0.f;
            for(int m = 0; m < num_meshes; ++m)
            {
                mesh* test_mesh = mesh_buffer + m;
                bvh_result current_result = bvh_hit(vec3(test_mesh->inv_model * vec4(origin, 1)), 
                    vec3(test_mesh->inv_model * vec4(direction, 0)), 
                    test_mesh->bvh, test_mesh->elements, test_mesh->vertices, nearest);

                if(current_result.near_distance < nearest)
                {
                    nearest = current_result.near_distance;
                    current_mesh = test_mesh;
                    result = current_result;
                }
            }

            if(result.hits)
            {
                vertex* mesh_vertices = (vertex*) current_mesh->vertices;
                triangle* tri = ((triangle*) current_mesh->elements)+result.near_triangle;
            
                #define barycentric_resolve(param) (mesh_vertices[tri->b].param * result.near_barycentric.x + \
                    mesh_vertices[tri->c].param * result.near_barycentric.y + \
                    mesh_vertices[tri->a].param * (1-result.near_barycentric.x-result.near_barycentric.y))

                vec3 norm = (current_mesh->model * vec4(barycentric_resolve(normal).xyz, 0)).xyz;
                vec3 pos = (current_mesh->model * vec4(barycentric_resolve(position).xyz, 1)).xyz;
                vec2 uv = barycentric_resolve(uv).xy;

                material* mat = ((material*) current_mesh->material) + 0;
                const float roughness = pow(mat->roughness_sqrt, 2);
                const float glass = mat->glass;
                const float ior = mat->ior;
                const float extinction_coefficient = mat->extinction_coefficient;
                const vec3 glass_tint = mat->glass_tint;
                const vec3 reflection_tint = mat->reflection_tint;
                const vec3 base_color = mat->base_color;

                const vec3 light_color = 1.f*vec3(1.f, 1, 1);
                const float light_radius = .1f;
                const vec3 light_pos = 0.2f * vec3(0.7, 2, 1);

                rand_val = random_value(int(pixel.x * 20323 + pixel.y * 43143 + 29012 * random_gen));
                random_sample = random_hammersley_2d(rand_val * count, 1/count);

                vec2 importance_sample = ggx_importance_sample(random_sample, roughness);
                vec3 hemi = ggx_importance_hemisphere(importance_sample);
                vec3 world_out = reflect(direction, bsdf_local_to_world(hemi, norm));
                vec3 facet_normal = bsdf_local_to_world(hemi, norm);
                vec3 forward_normal = faceforward(facet_normal, direction, facet_normal);
                bool swap = dot(direction, norm) > 0;
                float ior_in = swap ? ior : 1.f;
                float ior_out = swap ? 1.f : ior;
                vec3 world_out_refract = refract(direction, forward_normal, ior_in / ior_out) - 1e-4f * forward_normal;
                bsdf reflection = bsdf_reflection(direction, faceforward(norm, direction, norm), forward_normal, world_out, roughness);

                float fresnel = bsdf_fresnel_coefficient(direction, norm, ior, extinction_coefficient);

                vec3 light_offset_pos = light_pos + light_radius*uniform_sphere(random_sample);
                const vec3 to_light_full = light_offset_pos - pos;
                vec3 to_light = vec3(vec4(normalize(to_light_full), 0));

                bool total_ref = isTotalReflection(ior_in, ior_out, direction, forward_normal);

                if(random_value(2149) > fresnel && !total_ref)
                {
                    if(random_value(23103) > glass)
                    {
                        float distance_to_light = length(to_light_full);
                        float cos_light_angle = dot(to_light, norm);

                        if(cos_light_angle > 0)
                        {
                            bvh_state_set_mode(bvh_mode_any);

                            float d = max(cos_light_angle, 0.0f);
                            bvh_result shadow_test;
                            for(int m = 0; m < num_meshes; ++m)
                            {
                                mesh* test_mesh = mesh_buffer + m;
                                shadow_test = bvh_hit(vec3(test_mesh->inv_model * vec4(pos + forward_normal * 1e-2f, 1)), 
                                    vec3(current_mesh->inv_model * vec4(to_light, 0)), test_mesh->bvh, 
                                    test_mesh->elements, test_mesh->vertices, 
                                    distance_to_light);

                                if(shadow_test.hits) {
                                    d = 0;
                                    break;
                                }
                            }
                            color += rad * d * light_color * base_color * 0.5f;
                        }
                        rad *= base_color;// * (1-fresnel);
                        direction = bsdf_local_to_world(cosine_hemisphere(random_sample), norm);
                        origin = pos + 1e-3f * direction;
                    }
                    else
                    {
                        float dist = ggx_distribution(dot(-faceforward(norm, direction, norm), normalize(-direction+normalize(to_light_full))), roughness);
                        direction = world_out_refract;
                        bsdf transmission = bsdf_transmission(direction, norm, forward_normal, 
                            world_out_refract, roughness, ior);
                        //color += rad * dist * vec3(1.f, 0.97f, 0.90f);
                        rad *= pow(glass_tint, vec3(1/2.2f));
                        origin = pos + 1e-3f * direction;
                    }
                }
                else
                {
                    float dist = ggx_distribution(dot(faceforward(norm, direction, norm), normalize(-direction+normalize(to_light_full))), roughness);
                    direction = reflect(direction, forward_normal);
                    rad *= reflection_tint;
                    color += clamp(rad * dist * light_color * fresnel, vec3(0), vec3(1));
                    origin = pos + 1e-2f * facet_normal;
                    //color += vec3(1, 0, 0);
                }

                if(dot(rad, rad) < 0.00001f)
                    break;

            }
            else
            {
                alpha = 1-float(i==0);
                color += clamp(rad * texture(cubemap, direction).rgb * 4.f, vec3(0), vec3(3.f));
                break;
            }
        }
        imageStore(target_image, pixel, mix(last_color, vec4(color, alpha), 1.f/(max_samples + sample_blend_offset)));
    }
}