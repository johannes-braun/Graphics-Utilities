#include "../ext/bvh.h"
#include "../ext/random.h"
#include "../ext/bsdf.h"
#include "../ext/sampling.h"

#include "structures.h"

#define PI 3.1415926535
#define INV_PI 0.31830988618
#define TAU 6.282185317

const int bsdf_type_diffuse = 0;
const int bsdf_type_glass = 1;
const int bsdf_type_reflect = 2;

const float origin_epsilon = 1e-2f;
const float sqr_rad_cutoff = 1e-5f;

const float random_primes[6] = { 69019.f, 96013.f, 32159.f, 22783.f, 87011.f, 45263.f };

const vec3 light_color = 50.0f*vec3(1.f, 1, 1);
const float light_radius = 0.1f;
const vec3 light_pos = vec3(0, 4, 0);

layout(rgba16f) uniform image2D target_image;
uniform samplerCube cubemap;
uniform float random_gen;
uniform vec3 camera_position;
uniform mat4 camera_matrix;
uniform uintptr_t meshes;
uniform int num_meshes = 0;
uniform ivec2 offset;
uniform int max_samples = 2;
uniform int sample_blend_offset = 0;
uniform float max_bounces = 8;

void init_random(ivec2 pixel, float seed)
{
    random_value(int(pixel.x * random_primes[0] + pixel.y * random_primes[1] + random_primes[2] * seed));
}

int _current_prime = 0;
float next_random()
{
    return random_value(_current_prime = (_current_prime + 1) % 6);
}


layout(local_size_x = 16, local_size_y = 16) in; 
void main()
{
    ivec2 target_size = imageSize(target_image);
    float count = target_size.x * target_size.y;
    vec2 inv_target_size = 1.f / target_size;
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy)+offset;

    if(any(greaterThanEqual(pixel, target_size)))
        return;

    init_random(pixel, random_gen);

    for(int s=0; s<max_samples; ++s)
    {
        vec4 last_color = imageLoad(target_image, pixel);
        float alpha = 1.f;
        vec3 color = vec3(0);

        vec2 random_sample = random_hammersley_2d(next_random() * count, 1/count);
        vec2 uv = (pixel + random_sample) * inv_target_size - 0.5f;
        vec3 direction = normalize(vec3(camera_matrix * vec4(uv*2.f, 0, 1)));
        vec3 origin = camera_position;

        mesh* mesh_buffer = (mesh*)meshes;
        mesh* current_mesh;

        vec3 rad = vec3(1);
        for(int i=0; i < max_bounces && dot(rad, rad) > sqr_rad_cutoff; ++i)
        {
            direction = normalize(direction);

            bvh_result result;
            result.hits = false;
            float nearest = 1.f/0.f;
            bvh_state_set_mode(bvh_mode_nearest);
            for(int m = 0; m < num_meshes; ++m)
            {
                mesh* test_mesh = mesh_buffer + m;
                bvh_result current_result = bvh_hit(vec3(test_mesh->inv_model * vec4(origin, 1)), 
                    vec3(test_mesh->inv_model * vec4(direction, 0)), 
                    test_mesh->bvh, test_mesh->elements, test_mesh->vertices, nearest);

                if(current_result.near_distance < nearest)
                {
                    nearest = current_result.near_distance;
                    current_mesh = test_mesh;
                    result = current_result;
                }
            }

            if(result.hits)
            {
                vertex* vertices = (vertex*) current_mesh->vertices;
                triangle* triangles = ((triangle*) current_mesh->elements)+result.near_triangle;
                material* mesh_material = (material*) current_mesh->material;
            
                #define barycentric_resolve(param) (vertices[triangles->b].param * result.near_barycentric.x + \
                    vertices[triangles->c].param * result.near_barycentric.y + \
                    vertices[triangles->a].param * (1-result.near_barycentric.x-result.near_barycentric.y))

                vertex target_point;
                target_point.normal = vec4(normalize((current_mesh->model * vec4(barycentric_resolve(normal).xyz, 0)).xyz), 0);
                target_point.position = vec4((current_mesh->model * vec4(barycentric_resolve(position).xyz, 1)).xyz, 1);
                target_point.uv.xy = barycentric_resolve(uv).xy;
                mesh_material += uintptr_t(vertices[triangles->a].uv.z);

                const float roughness = (1.2 - 0.2 * sqrt(abs(dot(direction, target_point.normal.xyz)))) * pow(mesh_material->roughness_sqrt, 2);
                const float glass = mesh_material->glass;
                const float ior = mesh_material->ior;
                const float extinction_coefficient = mesh_material->extinction_coefficient;
                const vec3 glass_tint = mesh_material->glass_tint;
                const vec3 reflection_tint = mesh_material->reflection_tint;
                const vec3 base_color = mesh_material->base_color;

                random_sample = random_hammersley_2d(next_random() * count, 1/count);

                const vec3 light_offset_pos = light_pos + light_radius*uniform_sphere(random_sample);
                const vec3 to_light_full = light_offset_pos - target_point.position.xyz;
                const vec3 to_light = normalize(to_light_full);
                const float distance_to_light = length(to_light_full);

                const vec3 facet_normal = bsdf_local_to_world(ggx_importance_hemisphere(ggx_importance_sample(random_sample, roughness)), target_point.normal.xyz);
                const vec3 forward_normal = faceforward(facet_normal, direction, facet_normal);

                const bool swap = dot(direction, target_point.normal.xyz) > 0;
                const float ior_in = swap ? ior : 1.f;
                const float ior_out = swap ? 1.f : ior;
                const float fresnel = bsdf_fresnel_coefficient(direction, target_point.normal.xyz, ior, extinction_coefficient);
                const int target_bsdf = next_random() > fresnel && !bsdf_is_total_reflection(ior_in, ior_out, direction, forward_normal) ? 
                        (next_random() > glass ? bsdf_type_diffuse : bsdf_type_glass) : bsdf_type_reflect;

                float cos_light_angle = dot(to_light, target_point.normal.xyz);
                float d = max(cos_light_angle, 0.0f);
                        
                bvh_state_set_mode(bvh_mode_any);
                for(int m = 0; m < num_meshes && cos_light_angle > 0; ++m)
                {
                    mesh* test_mesh = mesh_buffer + m;
                    vec4 tr_orig = test_mesh->inv_model * (target_point.position + target_point.normal * origin_epsilon);
                    vec4 tr_dir = test_mesh->inv_model * vec4(to_light, 0);

                    if(bvh_hit(tr_orig.xyz, tr_dir.xyz, test_mesh->bvh, 
                        test_mesh->elements, test_mesh->vertices, 
                        distance_to_light).hits) {
                        d = 0;
                        break;
                    }
                }

                switch(target_bsdf) {
                    // ----------------------------------------------------------------------------------------------------------------
                    case bsdf_type_diffuse:
                    {
                        color += clamp(rad * d * light_color * base_color / (1 + distance_to_light * distance_to_light), vec3(0), max(vec3(30.f / (3.7f*i+1)), vec3(1.f)));
                        rad *= base_color;
                        direction = bsdf_local_to_world(cosine_hemisphere(random_sample), target_point.normal.xyz);
                        origin = target_point.position.xyz + origin_epsilon * direction;
                    }
                    break;
                    // ----------------------------------------------------------------------------------------------------------------
                    case bsdf_type_glass:
                    {
                        float t = result.near_distance;
                        bool outgoing = dot(forward_normal, facet_normal) < 0;
                        float scatter_factor = (outgoing ? 1/abs(1.f+pow(mesh_material->glass_density*t, mesh_material->glass_density_falloff)) : 1);
                        vec3 glass_color = pow(glass_tint, vec3(1/2.2f));
                        color += rad * glass_color * (1-scatter_factor) * mesh_material->glass_scatter_color;
                        rad *= scatter_factor * glass_color;
                        direction = refract(direction, forward_normal, ior_in / ior_out) - origin_epsilon * forward_normal;
                        origin = target_point.position.xyz + origin_epsilon * direction;
                        i = max(i-1, 1);
                    }
                    break;
                    // ----------------------------------------------------------------------------------------------------------------
                    case bsdf_type_reflect:
                    {
                        vec3 light_half_vector = normalize(-direction + normalize(to_light_full));
                        float distribution_light = clamp(ggx_distribution(abs(dot(target_point.normal.xyz, light_half_vector)), roughness), 0.f, 1.f);
                        rad *= reflection_tint;

                        vec3 d_rad = clamp(rad * distribution_light * max(dot(to_light, target_point.normal.xyz), 0.f), 0, 1.f);
                        color += clamp(d * d_rad * light_color * PI / (1 + distance_to_light * distance_to_light), vec3(0), max(vec3(30.f / (3.7f*i+1)), vec3(1.f)));

                        direction = reflect(direction, forward_normal);
                        origin = target_point.position.xyz + origin_epsilon * direction;
                    }
                    break;
                    // ----------------------------------------------------------------------------------------------------------------
                }
            }
            else
            {
                float first = float(i==0);
                alpha = 1-first;
                vec3 unclamped = rad * texture(cubemap, direction).rgb * 4.f;
                color += clamp(unclamped, vec3(0), vec3(6.f + first * 10.f));
                break;
            }
        }

        vec3 mapped = pow(color, vec3(1/1.5f));

        imageStore(target_image, pixel, mix(last_color, vec4(mapped, alpha), 1.f/(max_samples + sample_blend_offset)));
    }
}