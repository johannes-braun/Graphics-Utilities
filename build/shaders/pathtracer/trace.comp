#include "../ext/bvh.h"
#include "../ext/random.h"
#include "../ext/bsdf.h"
#include "../ext/sampling.h"

#include "structures.h"

#define PI 3.1415926535
#define INV_PI 0.31830988618
#define TAU 6.282185317

const int bsdf_type_glass = 0;
const int bsdf_type_reflect = 1;
const int bsdf_type_surface = 2;

const float origin_epsilon = 1e-3f;
const float sqr_rad_cutoff = 1e-2f;

const float random_primes[6] = { 69019.f, 96013.f, 32159.f, 22783.f, 87011.f, 45263.f };

const vec3 light_color = 10.0f*vec3(1.f, 1, 1);
const float light_radius = 0.1f;
const vec3 light_pos =vec3(-5, 4, 2);

layout(binding = 0, std140) uniform Infos
{
    ivec2 offset;
    float random_gen;
    int num_meshes;
    layout(rgba32f) image2D target_image;
    samplerCube cubemap;
    mat4 camera_matrix;
    mesh* meshes;    
    int sample_blend_offset;
    int max_bounces;
    vec3 camera_position;
    int max_samples;
};

void init_random(ivec2 pixel, float seed)
{
    random_value(int(pixel.x * random_primes[0] + pixel.y * random_primes[1] + random_primes[2] * seed));
}

int _current_prime = 0;
float next_random()
{
    return random_value(_current_prime = (_current_prime + 1) % 6);
}

struct resolve_vertex
{
    vec4 position;
    vec4 normal;
    vec2 uv;
};

layout(local_size_x = 16, local_size_y = 16) in; 
void main()
{
    ivec2 target_size = imageSize(target_image);
    float count = target_size.x * target_size.y;
    vec2 inv_target_size = 1.f / target_size;
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy) + offset;

    if(any(greaterThanEqual(pixel, target_size)))
        return;

    init_random(pixel, random_gen);

    for(int s=0; s<max_samples; ++s)
    {
        vec4 last_color = imageLoad(target_image, pixel);
        float alpha = 1.f;
        vec3 color = vec3(0);

        vec2 random_sample = random_hammersley_2d(next_random() * count, 1/count);
        vec2 uv = (pixel + random_sample) * inv_target_size - 0.5f;
        vec3 direction = normalize(vec3(camera_matrix * vec4(uv*2.f, 0, 1)));
        vec3 origin = camera_position;

        mesh* mesh_buffer = meshes;
        mesh* current_mesh;

        vec3 rad = vec3(1);
        float inside_depth = 0;
        for(int i=0; i < max_bounces && length(rad) > 0.01; ++i)
        {
            direction = normalize(direction);

            bvh_result result;
            result.hits = false;
            float nearest = 100000000.f;
            bvh_state_set_mode(bvh_mode_nearest);
            for(int m = 0; m < num_meshes; ++m)
            {
                mesh* test_mesh = mesh_buffer + m;
                bvh_result current_result = bvh_hit(vec3(test_mesh->inv_model * vec4(origin, 1)), 
                    vec3(test_mesh->inv_model * vec4(direction, 0)), 
                    test_mesh->bvh, test_mesh->elements, test_mesh->vertices, nearest);

                if(current_result.near_distance < nearest)
                {
                    nearest = current_result.near_distance;
                    current_mesh = test_mesh;
                    result = current_result;
                }
            }

            if(result.hits)
            {
                vertex* vertices = (vertex*) current_mesh->vertices;
                triangle* triangles = ((triangle*) current_mesh->elements)+result.near_triangle;
                material* mesh_material = (material*) current_mesh->material;
            
                #define barycentric_resolve(param) (vertices[triangles->b].param * result.near_barycentric.x + \
                    vertices[triangles->c].param * result.near_barycentric.y + \
                    vertices[triangles->a].param * (1-result.near_barycentric.x-result.near_barycentric.y))

                const vec3 resolved_normal = barycentric_resolve(normal);

                resolve_vertex target_point;
                target_point.normal = vec4(normalize((current_mesh->model * vec4(resolved_normal, 0)).xyz), 0);
                target_point.position = vec4((current_mesh->model * vec4(barycentric_resolve(position), 1)).xyz, 1);
                target_point.uv = barycentric_resolve(uv);
                mesh_material += uintptr_t(vertices[triangles->a].meta);

                const float roughness = (1.2 - 0.2 * sqrt(abs(dot(direction, target_point.normal.xyz)))) * pow(mesh_material->ground_roughness, 2);
                const float surface_roughness = (1.2 - 0.2 * sqrt(abs(dot(direction, target_point.normal.xyz)))) * pow(mesh_material->surface_roughness, 2);
                // const float glass = mesh_material->glass;
                // const float ior = mesh_material->ior;
                // const float extinction_coefficient = mesh_material->extinction_coefficient;
                // const vec3 glass_tint = mesh_material->glass_tint;
                // const vec3 reflection_tint = mesh_material->reflection_tint;
                // const vec3 base_color = mesh_material->base_color;

                random_sample = random_hammersley_2d(next_random() * count, 1/count);

                const vec3 light_offset_pos = light_pos + light_radius*uniform_sphere(random_sample);
                const vec3 to_light_full = light_offset_pos - target_point.position.xyz;
                const vec3 to_light = normalize(to_light_full);
                const float distance_to_light = length(to_light_full);

                const vec3 facet_normal = bsdf_local_to_world(ggx_importance_hemisphere(ggx_importance_sample(random_sample, roughness)), target_point.normal.xyz);
                const vec3 forward_normal = faceforward(facet_normal, direction, facet_normal);
                const vec3 facet_normal_surface = bsdf_local_to_world(ggx_importance_hemisphere(ggx_importance_sample(random_sample, surface_roughness)), target_point.normal.xyz);
                const vec3 forward_normal_surface = faceforward(facet_normal_surface, direction, facet_normal_surface);

                const bool swap = dot(direction, target_point.normal.xyz) > 0;
                const float ior_in = swap ? mesh_material->ior : 1.f;
                const float ior_out = swap ? 1.f : mesh_material->ior;
                const float fresnel = bsdf_fresnel_coefficient(direction, target_point.normal.xyz, mesh_material->ior, mesh_material->extinction);
                const int target_bsdf = next_random() > fresnel && !bsdf_is_total_reflection(ior_in, ior_out, direction, forward_normal) ? 
                        (next_random()+0.01f > mesh_material->ground_transmissiveness ? bsdf_type_reflect : bsdf_type_glass) : (swap ? bsdf_type_reflect : bsdf_type_surface);

                float cos_light_angle = dot(to_light, target_point.normal.xyz);
                float d = max(cos_light_angle, 0.0f);
                        
                bvh_state_set_mode(bvh_mode_any);
                for(int m = 0; m < num_meshes && cos_light_angle > 0; ++m)
                {
                    mesh* test_mesh = mesh_buffer + m;
                    vec4 tr_orig = test_mesh->inv_model * (target_point.position + target_point.normal * origin_epsilon);
                    vec4 tr_dir = test_mesh->inv_model * vec4(to_light, 0);

                    if(bvh_hit(tr_orig.xyz, tr_dir.xyz, test_mesh->bvh, 
                        test_mesh->elements, test_mesh->vertices, 
                        distance_to_light).hits) {
                        d = 0;
                        break;
                    }
                }

                bool outgoing = dot(forward_normal, facet_normal) < 0;
                inside_depth += result.near_distance * float(outgoing);
                float scatter_factor = (outgoing ? 1 / abs(1.f + pow(mesh_material->ground_density*inside_depth, mesh_material->ground_density_falloff)) : 1);

                switch(target_bsdf) {
                    // ----------------------------------------------------------------------------------------------------------------
                    case bsdf_type_glass:
                    {
                        vec3 glass_color = pow(mesh_material->ground_scatter_color, vec3(1/2.2f));
                        color += rad * glass_color * (1-scatter_factor) * mesh_material->ground_density_color;
                        rad *= scatter_factor * glass_color;
                        direction = refract(direction, forward_normal, ior_in / ior_out) - origin_epsilon * forward_normal;
                        origin = target_point.position.xyz + origin_epsilon * direction;
                        i = max(i-1, 1);
                    }
                    break;
                    // ----------------------------------------------------------------------------------------------------------------
                    case bsdf_type_reflect:
                    {
                        vec3 ref_color = mesh_material->ground_reflection_color;

                        vec3 light_half_vector = normalize(-direction + normalize(to_light_full));
                        float distribution_light = clamp(ggx_distribution(abs(dot(target_point.normal.xyz, light_half_vector)), roughness), 0.f, 1.f);
                        float distribution_thing = clamp(ggx_distribution(abs(dot(target_point.normal.xyz, normalize(facet_normal))), roughness), 0.f, 1.f);

                        //color += rad * ref_color * (1 - scatter_factor) * mesh_material->ground_density_color;
                        rad *= ref_color;

                        vec3 d_rad = clamp(rad * distribution_light * max(dot(to_light, target_point.normal.xyz), 0.f), 0, 1.f);
                        color += clamp(d * d_rad * light_color * PI / (1 + distance_to_light * distance_to_light), vec3(0), max(vec3(30.f / (3.7f*i+1)), vec3(1.f)));

                        direction = normalize(reflect(direction, forward_normal));
                        if (dot(direction, forward_normal) < 0)
                            direction += 2 * dot(direction, forward_normal)*forward_normal;
                        origin = target_point.position.xyz + origin_epsilon * target_point.normal.xyz;
                    }
                    break;
                    // ----------------------------------------------------------------------------------------------------------------
                    case bsdf_type_surface:
                    {
                        vec3 ref_color = mesh_material->surface_reflection_color;

                        vec3 light_half_vector = normalize(-direction + normalize(to_light_full));
                        float distribution_light = clamp(ggx_distribution(abs(dot(target_point.normal.xyz, light_half_vector)), surface_roughness), 0.f, 1.f);

                       // color += rad * ref_color * (1 - scatter_factor) * mesh_material->ground_density_color;
                        rad *= ref_color;

                        vec3 d_rad = clamp(rad * distribution_light * max(dot(to_light, target_point.normal.xyz), 0.f), 0, 1.f);
                        color += clamp(d * d_rad * light_color * PI / (1 + distance_to_light * distance_to_light), vec3(0), max(vec3(30.f / (3.7f*i+1)), vec3(1.f)));

                        direction = normalize(reflect(direction, forward_normal_surface));
                        if (dot(direction, forward_normal_surface) < 0)
                            direction += 2 * dot(direction, forward_normal_surface)*forward_normal_surface;
                        origin = target_point.position.xyz + origin_epsilon * target_point.normal.xyz;
                    } break;
                }
            }
            else
            {
                float first = float(i==0);
                alpha = 1-first;
                vec3 unclamped = rad * texture(cubemap, direction).rgb * 4.f;
                color += clamp(unclamped, vec3(0), vec3(6.f + first * 10.f));
                rad = vec3(0);
                break;
            }
        }

        vec3 mapped = color;
        imageStore(target_image, pixel, mix(last_color, vec4(mapped, alpha), 1.f/(max_samples + sample_blend_offset)));
    }
}