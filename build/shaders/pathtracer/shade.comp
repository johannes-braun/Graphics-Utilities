#include "../ext/bvh.h"
#include "../ext/random.h"
#include "../ext/bsdf.h"

layout(local_size_x = 64) in;

layout(rgba16f) uniform image2D target_image;
layout(rgba16f) uniform image2D rad_image;
uniform samplerCube cubemap;
uniform float random_gen;

uniform uintptr_t vertices;
uniform uintptr_t elements;
uniform uintptr_t bvh;

struct vertex {
    vec4 position;
    vec4 uv;
    vec4 normal;
};

struct triangle {
    uint a;
    uint b;
    uint c;
};

struct ray
{
    vec4 origin_px;
    vec4 direction_py;
    vec2 barycentric;
    int mesh;
    int triangle;
};

layout(binding = 0) restrict buffer RayBuffer
{
    ray rays[];
};

vec3 cosine_hemisphere(vec2 uv)
{
	// (Uniformly) sample a point on the unit disk
    float r = sqrt(uv.x);
    float theta = 2 * 3.14152692 * uv.y;
    float x = r * cos(theta);
    float y = r * sin(theta);

    // Project point up to the unit sphere
    float z = sqrt(max(0.f, 1 - x * x - y * y));
    return vec3(x, y, z);
}

void main()
{
    if(gl_GlobalInvocationID.x > rays.length())
        return;
    ray r = rays[gl_GlobalInvocationID.x];
    ivec2 pixel = ivec2(r.origin_px.w, r.direction_py.w);

    vec3 color = imageLoad(target_image, pixel).rgb;
    vec3 rad = imageLoad(rad_image, pixel).rgb;
    vec3 last_color = imageLoad(target_image, pixel).rgb;
    if(r.mesh == -2)
    {
        color = rad * texture(cubemap, r.direction_py.xyz).rgb;
    }
    else
    {
        ivec2 target_size = imageSize(target_image);
        float count = target_size.x * target_size.y;
    
        vertex* mesh_vertices = (vertex*) vertices;
        triangle* tri = ((triangle*)elements)+r.triangle;
        #define barycentric_resolve(param) (mesh_vertices[tri->b].param * r.barycentric.x + \
            mesh_vertices[tri->c].param * r.barycentric.y + \
            mesh_vertices[tri->a].param * (1-r.barycentric.x-r.barycentric.y))
        
        vec3 norm = barycentric_resolve(normal).xyz;
        vec3 pos = barycentric_resolve(position).xyz;
        vec2 uv = barycentric_resolve(uv).xy;

        float rand_val = random_value(int(pixel.x * 20323 + pixel.y * 43143 + 29012 * random_gen));
        vec2 random_sample = random_hammersley_2d(rand_val * count, 1/count);
        r.direction_py.xyz = bsdf_local_to_world(cosine_hemisphere(random_sample), norm);
        r.origin_px.xyz = pos + 1e-3f * r.direction_py.xyz;
        //color = r.direction_py.xyz;
        rad *= vec3(0.f, 0.4f, 1.f);
    }

    imageStore(rad_image, pixel, vec4(rad, 1));
    imageStore(target_image, pixel, vec4(color, 1));
}