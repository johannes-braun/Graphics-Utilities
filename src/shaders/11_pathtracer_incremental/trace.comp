#version 460 core

layout(local_size_x = 16, local_size_y = 16) in;
layout(binding = 0, rgba32f) uniform image2D accumulation_cache;
layout(binding = 1, rgba32f) uniform image2D bounce_cache;
layout(binding = 2, rgba32f) uniform image2D direction_cache;
layout(binding = 3, rgba32f) uniform image2D origin_cache;
layout(binding = 4, rg32ui) uniform uimage2D counter_cache;
layout(binding = 5, rgba8)	 uniform image2D color_output;
layout(binding = 0) uniform samplerCube cubemap;
layout(binding = 0) uniform Camera
{
	mat4 view;
	mat4 proj;
	vec3 position;
} camera;

layout(binding = 1) uniform HelperInfo
{
	mat4 inverse_view_proj;
	float time;
	uint reset;
};

bool intersect_bounds(
    const vec3 origin,
    const vec3 direction,
    const vec3 bounds_min,
    const vec3 bounds_max,
    const float max_distance,
    inout float min_distance,
    inout float out_max_distance, inout int face_tmin, inout int face_tmax);

vec2 random_hammersley_2d(float current, float inverse_sample_count)
{
    vec2 result;
    result.x = current * inverse_sample_count;

    // Radical inverse
	uint bits = uint(current);
    bits = (bits << 16u) | (bits >> 16u);
	bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
	bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
	bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
	bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
	result.y = float(bits) * 2.3283064365386963e-10f;
    return result;
}

vec2 ggx_importance_sample(const in vec2 random_sample, const in float roughness);
vec3 ggx_importance_hemisphere(const in vec2 importance_sample);
vec3 bsdf_local_to_world(const in vec3 vector, const in vec3 normal) {
    // Find an axis that is not parallel to normal
    vec3 u = normalize(cross(normal, (abs(normal.x) <= 0.6f) ? vec3(1, 0, 0) : vec3(0, 1, 0)));
    return normalize(mat3(u, cross(normal, u), normal) * vector);
}

//Method to generate a pseudo-random seed.
uint random_wang_hash(uint a)
{
	a = (a ^ 61) ^ (a >> 16);

	a = a + (a << 3);
	a = a ^ (a >> 4);
	a = a * 0x27d4eb2d;
	a = a ^ (a >> 15);
	return a;
}

uint _rng_state = 0;
uint random_xorshift()
{
	// Xorshift algorithm from George Marsaglia's paper
	_rng_state ^= (_rng_state << 13);
	_rng_state ^= (_rng_state >> 17);
	_rng_state ^= (_rng_state << 5);
	return _rng_state;
}

const float inverse_max_uint = 1.f / float(0xFFFFFFFFu);
float random_value(int seed)
{
    _rng_state += random_wang_hash(uint(seed));
	return clamp(float(random_xorshift()) * inverse_max_uint, 0.f, 1.f);
}
const float random_primes[6] = { 69019.f, 96013.f, 32159.f, 22783.f, 87011.f, 45263.f };
int _current_prime = 0;
void init_random(ivec2 pixel, float seed)
{
    random_value(int(pixel.x * random_primes[0] + pixel.y * random_primes[1] + random_primes[2] * seed));
}
float next_random()
{
    return random_value(_current_prime = (_current_prime + 1) % 6);
}


void main()
{
	ivec2 pixel		= ivec2(gl_GlobalInvocationID.xy);
	ivec2 img_size	= ivec2(imageSize(accumulation_cache));
	if(any(greaterThanEqual(pixel, img_size)))
		return;

	init_random(pixel, int(reset * 20*time));
	vec2 random_value = random_hammersley_2d(int(pixel.y * img_size.x + pixel.x + next_random() * img_size.x * img_size.y) % (img_size.x * img_size.y), 1.f / (img_size.x * img_size.y));
	vec3 precalc_direction = vec3(inverse_view_proj * vec4((((pixel + random_value) / vec2(img_size)) * 2 - 1), 0.f, 1.f));

	uvec2 c_counters	= reset != 0 ? imageLoad(counter_cache, pixel).xy : uvec2(0);
	vec4 c_accumulation = reset != 0 ? imageLoad(accumulation_cache, pixel) : vec4(0);
	vec4 c_bounce		= reset != 0 && c_counters.x != 0 ? imageLoad(bounce_cache, pixel) : vec4(0);
	vec4 c_direction	= reset != 0 && c_counters.x != 0 ? imageLoad(direction_cache, pixel) : vec4(precalc_direction, 0);
	vec4 c_origin		= reset != 0 && c_counters.x != 0 ? imageLoad(origin_cache, pixel) : vec4(camera.position, 0);
	vec4 c_display_color = vec4(0.f);

	// READ ----------------------------------------

	for(int i=0; i < 80; ++i)
	{
		if(c_counters.x == 0)
		{
			random_value = random_hammersley_2d(int(pixel.y * img_size.x + pixel.x + next_random() * img_size.x * img_size.y) % (img_size.x * img_size.y), 1.f / (img_size.x * img_size.y));
			precalc_direction = vec3(inverse_view_proj * vec4((((pixel + random_value) / vec2(img_size)) * 2 - 1), 0.f, 1.f));
			c_bounce = vec4(0);
			c_direction = vec4(precalc_direction, 0);
			c_origin = vec4(camera.position, 0);
		}

		float out_min, out_max;
		int out_fmin, out_fmax;
		if( intersect_bounds(c_origin.xyz, c_direction.xyz, vec3(-1), vec3(1), 1.f / 0.f, out_min, out_max, out_fmin, out_fmax))
		{
			int min_sgn = out_fmin > 2 ? 1 : -1;
			vec3 min_norm = vec3(0);
			min_norm[out_fmin % 3] = min_sgn;

			float roughness = 0.15f;

			float alpha2 = roughness * roughness;
			vec3 normal = min_norm;
			vec3 msnormal = bsdf_local_to_world(ggx_importance_hemisphere(ggx_importance_sample(random_value,alpha2)), normal);
		
			c_origin = c_origin + out_min * c_direction;
			c_direction = vec4(reflect(c_direction.xyz, msnormal), 0);
			c_origin += c_direction * 1e-3f;
			c_bounce += vec4(normal, 1);
		
			float den = ++c_counters.x;
			if(den > 5)
			{
				c_counters.y;
				c_accumulation += c_bounce / den;
				c_bounce = vec4(0);
				c_counters.x = 0;
			}
			c_display_color = (c_accumulation+c_bounce / den) / (c_counters.y+1);
		}
		else
		{
			c_bounce += texture(cubemap, c_direction.xyz);
		
			float den = ++c_counters.x;
			if(den > 1)
			{
				++c_counters.y;
				c_accumulation += c_bounce / den;
				c_bounce = vec4(0);
				c_counters.x = 0;
			}
			c_display_color = (c_accumulation+c_bounce / den) / (c_counters.y+1);
		}
	}
	// WRITE ----------------------------------------

	imageStore(color_output,		pixel, c_display_color);
	imageStore(counter_cache,		pixel, uvec4(c_counters, 0, 0));
	imageStore(accumulation_cache,	pixel, c_accumulation);
	imageStore(bounce_cache,		pixel, c_bounce);
	imageStore(direction_cache,		pixel, c_direction);
	imageStore(origin_cache,		pixel, c_origin);
}

vec2 ggx_importance_sample(const in vec2 random_sample, const in float roughness)
{
  float phi = random_sample.y * 2.f * 3.14156235659f;
  float rough2 = roughness*roughness;
  float theta = atan(sqrt(rough2 * random_sample.x / (1 - random_sample.x)));
  return vec2(phi, theta);
}

vec3 ggx_importance_hemisphere(const in vec2 importance_sample)
{
  float phi = importance_sample.x;
  float cosTheta = cos(importance_sample.y);
  float sinTheta = sin(importance_sample.y);
  return vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);
}

int faceID(float t, float t1, float t2, float t3, float t4, float t5, float t6) {
    return t == t1 ? 0 	//neg_x
        : (t == t2 ? 3 	//pos_x
            : (t == t3 ? 1 	//neg_y
                : (t == t4 ? 4 	//pos_y
                    : (t == t5 ? 2 	//neg_z
                        : 5))));		//pos_z
}

bool intersect_bounds(
    const vec3 origin,
    const vec3 direction,

    const vec3 bounds_min,
    const vec3 bounds_max,
    const float max_distance,
    inout float min_distance,
    inout float out_max_distance, inout int face_tmin, inout int face_tmax)
{
    vec3 inv_direction = 1.f / direction;

    //intersections with box planes parallel to x, y, z axis
    vec3 t135 = (bounds_min - origin) * inv_direction;
    vec3 t246 = (bounds_max - origin) * inv_direction;

    vec3 min_values = min(t135, t246);
    vec3 max_values = max(t135, t246);

    float tmin = max(max(min_values.x, min_values.y), min_values.z);
    float tmax = min(min(max_values.x, max_values.y), max_values.z);

    face_tmin = faceID(tmin, t135.x, t246.x, t135.y, t246.y, t135.z, t246.z);
    face_tmax = faceID(tmax, t135.x, t246.x, t135.y, t246.y, t135.z, t246.z);

    min_distance = min(tmin, tmax);
    out_max_distance = max(tmin, tmax);
    return tmax >= 0 && tmin <= tmax && tmin <= max_distance;
}