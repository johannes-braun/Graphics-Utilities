layout(local_size_x = 32) in;

struct spring
{
    int particle1;
    int particle2;
    float stiff;
    float damping;
    float length;
    float _p[3];
};

struct vertex
{
    vec3 position;
    uint meta;
    vec3 normal;
    uint meta2;
    vec2 uv;
    uint meta3[2];
};

layout(binding = 0) uniform Data
{
    restrict vec4* spring_results; 
    restrict vec4* particle_velocities; 
    restrict spring* springs; 
    restrict vertex* vertices;
    restrict uint* vertex_springs;
    int spring_count;
    int vertex_count;
    mat4 inv_model;
};

const int springs_per_particle = 12;

void main()
{
    if(gl_GlobalInvocationID.x >= spring_count)
        return;

    spring s = springs[gl_GlobalInvocationID.x];
    vertex v1 = vertices[s.particle1];
    vertex v2 = vertices[s.particle2];
    vec4 vel1 = particle_velocities[s.particle1];
    vec4 vel2 = particle_velocities[s.particle2];

    // Register springs as processed for indexing when integrating.
    uint result1 = (springs_per_particle) * s.particle1 + atomicAdd(vertex_springs + s.particle1, 1);
    uint result2 = (springs_per_particle) * s.particle2 + atomicAdd(vertex_springs + s.particle2, 1);

    // Calculate spring forces
    vec3 difference = v1.position - v2.position;
    vec3 total_force = s.stiff * (s.length - length(difference)) * normalize(difference);

    // Put counteracting forces into the result buffer with a little damping
    vec3 damping = s.damping * (vel2.xyz - vel1.xyz);
    spring_results[result1] = vec4(total_force + damping, 0);
    spring_results[result2] = -spring_results[result1];
}